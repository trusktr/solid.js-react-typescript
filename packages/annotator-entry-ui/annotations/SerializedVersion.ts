/**
 *  Copyright 2018 Mapper Inc.
 *  CONFIDENTIAL. AUTHORIZED USE ONLY. DO NOT REDISTRIBUTE.
 */

import {UtmJson} from "./AnnotationBase"
import {LaneEntryExitType, LaneJsonInputInterfaceV1, LaneJsonInputInterfaceV3, LaneLineType} from "./Lane"

// tslint:disable:no-string-literal

export const currentAnnotationFileVersion = 4

// Get the file-format version of a serialized annotations object.
function annotationsFileVersion(data: Object): number {
	if (!data['version']) {
		// First version didn't have a version number.
		return 1
	} else {
		// All other versions are sequential integers.
		const version = parseInt(data['version'], 10)
		if (isNaN(version) || version < 2 || version > currentAnnotationFileVersion)
			throw Error(`invalid annotations file version ${data['version']}`)
		else
			return version
	}
}

// Files generated under this version, in late 2017, were marked with MGRS zone 18S regardless
// of whether the data came from DC or SF. We have no way of knowing the difference. Assume SF.
function oneToTwo(data: Object): Object {
	data['coordinateReferenceSystem']['parameters']['utmZoneNumber'] = 10
	data['coordinateReferenceSystem']['parameters']['utmZoneNorthernHemisphere'] = true

	return data
}

// This version changed the label for "markerPositions" and converts numeric enums to strings.
function twoToFour(data: Object): Object {
	data['annotations'] = data['annotations'].map((v1: LaneJsonInputInterfaceV1) => {
		return {
			annotationType: "LANE",
			uuid: v1.uuid,
			laneType: "UNKNOWN",
			markers: v1.markerPositions,
			neighborsIds: v1.neighborsIds,
			leftLineType: LaneLineType[v1.leftSideType],
			leftLineColor: "UNKNOWN",
			rightLineType: LaneLineType[v1.rightSideType],
			rightLineColor: "UNKNOWN",
			entryType: LaneEntryExitType[v1.entryType],
			exitType: LaneEntryExitType[v1.exitType],
		} as LaneJsonInputInterfaceV3
	})

	return data
}

// This version had a flipped coordinate system with negative UTM values.
function threeToFour(data: Object): Object {
	const flipUtmV3 = (utm: UtmJson): UtmJson => {
		return {'E': -utm['N'], 'N': utm['E'], 'alt': utm['alt']}
	}
	data['annotations'].forEach((v3: Object) => {
		v3['markers'] = v3['markers'].map(m => flipUtmV3(m))
	})

	return data
}

// Convert a data structure to the latest version of those generated by AnnotationManager
// when it serializes its annotations. The input is assumed to be some raw deserialized
// object of any current or past version. Output is an updated object ready for processing
// by AnnotationManager.
// Warning: this will destroy the input data (and return it to you as output).
export function toCurrentAnnotationVersion(data: Object): Object {
	const startVersion = annotationsFileVersion(data)
	delete data['version']

	// Each update moves data forward from one state to the next.
	let updaters: ((_: Object) => Object)[]
	switch (startVersion) {
		case 1:
			updaters = [
				oneToTwo,
				twoToFour,
			]
			break
		case 2:
			updaters = [
				twoToFour,
			]
			break
		case 3:
			updaters = [
				threeToFour,
			]
			break
		case 4:
			updaters = [
			]
			break
		default:
			throw Error(`SerializedVersion is missing an updater for file version (${startVersion})`)
	}

	updaters.forEach(updater =>
		data = updater(data)
	)
	return data
}
